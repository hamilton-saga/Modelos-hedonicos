# ===========================================================================
# MODELO HED√ìNICO PARA TABLET
# Metodolog√≠a | Basado en buenas pr√°cticas del BLS y Eurostat
# Analista: Arnold Jefferson Sanchez Garagate
# Fecha: 18-09-2025
# Producto: Tablet
# Per√≠odo base: Enero - setiembre 2025
# ===========================================================================

# --- LIBRER√çAS NECESARIAS ---
library(tidyverse)  # Manipulaci√≥n de datos
library(caret)
library(readxl)     # Leer Excel
library(dplyr)
library(sandwich)   # Errores robustos
library(broom)
library(knitr)
library(car)        # VIF, pruebas estad√≠sticas
library(ggplot2)
library(randomForest)
library(lmtest)   # Para bptest
library(nortest)  # Para alternativa a shapiro.test en muestras grandes
library(broom)  #mostrar tabla comparativa
library(modelsummary)


# --- 1. CARGA DE DATOS ---
df <- read_excel("D:/ASANCHEZ/02_ASANCHEZ_2025/05_Modelos_hedonicos/05_TABLET/bd_tablet_octubre25.xlsx", 
                                  sheet = "FINAL") %>%

    mutate(
    # Convertir variables categ√≥ricas a factor
    tienda = as.factor(tienda),
    marca = as.factor(marca),
    modelo = as.factor(modelo),
    resolucion = as.factor(resolucion),
    procesador = as.factor(procesador),
    clasificacion = as.factor(clasificacion)
   )

# Transformar el precio a ln_precio
df <- df %>% mutate(ln_precio = log(PRECIO))
#view(df)

df$almacenamiento <- as.numeric(as.character(df$almacenamiento))
df$ram <- as.numeric(as.character(df$ram))
df$screen_size <- as.numeric(as.character(df$screen_size))
df$camara_frontal <- as.numeric(as.character(df$camara_frontal))
df$camara_posterior <- as.numeric(as.character(df$camara_posterior))
df$peso <- as.numeric(as.character(df$peso))
df$capacidad_bateria <- as.numeric(as.character(df$capacidad_bateria))

#-----------------------------------------------------------

# SELECCI√ìN DE MODELO BASADA EN AIC: balance entre ajuste y parsinomia

#-----------------------------------------------------------------
# Criterio de informaci√≥n AIC
m_lineal <- lm(ln_precio ~ ram, data = df)
m_cuadratico <- lm(ln_precio ~ ram + I(ram^2), data = df)
m_log <- lm(ln_precio ~ log(ram), data = df)
m_poly3 <- lm(ln_precio ~ poly(ram, 3, raw = TRUE), data = df)

AIC(m_lineal, m_cuadratico, m_log, m_poly3)
#-----------------------------------------------------------------#

# ===========================================================================
# MODELO ECONOMETRICO DE LAPTOP - GPU DEDIDACA
# modelo hed√≥nico por M√≠nimos Cuadrados Ordinarios (MCO)     
# ===========================================================================

# --- 1. Estimar modelos ---

# Modelo 1: Lineal

#Poner como base a una marca representativa en el modelo
df$marca <- relevel(df$marca, ref = "LENOVO")

model_y1 <- lm(
  ln_precio ~ 
    #almacenamiento +
    poly(almacenamiento,2,raw = TRUE) +
    ram +
    #screen_size +
    poly(screen_size,2,raw = TRUE) +
    camara_frontal +
    camara_posterior +
    peso + 
    capacidad_bateria +
    marca +
    #resolucion +
    #tienda +
    #mes +
    clasificacion,  
  data = df
)

summary(model_y1)


# --- 2. Extraer resultados ---
tabla <- modelsummary(
  list("Lineal" = model_m1, "Cuadr√°tico" = model_m2, "Logaritmo" = model_m3, "Polinomio" = model_m4),
  gof_omit = "AIC|BIC|F|Log",
  estimate = "{estimate} ({std.error})",
  statistic = NULL,
  stars = TRUE,
  notes = c("Errores est√°ndar entre par√©ntesis.",
            "Significancia: *** p<0.01, ** p<0.05, * p<0.1")
)

# Mostrar tabla
print(tabla)

# 5. Diagn√≥sticos del modelo ------------------------------------------------

# Resumen del modelo (coeficientes, significancia, R¬≤)
summary(model_y1)

# Factor de Inflaci√≥n de Varianza (VIF) - detecta multicolinealidad
vif_values <- vif(model_y1)
print("üîç FACTOR DE INFLACI√ìN DE VARIANZA (VIF)")
print(vif_values)
# ‚ö†Ô∏è Advertencia si VIF > 5 o 10

# Prueba de heterocedasticidad: Breusch-Pagan
bp_test <- bptest(model_y1)
print("üîç PRUEBA DE BREUSCH-PAGAN (heterocedasticidad)")
print(bp_test)
# Si p < 0.05 ‚Üí hay heterocedasticidad

# Coeficientes con errores est√°ndar robustos (recomendado para IPC)
cat("\nüìä COEFICIENTES CON ERRORES ROBUSTOS (HC1)\n")
coeftest(model_y1, vcov = vcovHC(model_y1, type = "HC3"))

# Prueba de White (alternativa, √∫til si hay muchos regresores)
white_test <- ncvTest(model_y1)
print("üîç PRUEBA DE WHITE (no linealidad en varianza)")
print(white_test)

# 6. An√°lisis gr√°fico de residuos -------------------------------------------
# Deben cumplirse supuestos cl√°sicos

par(mfrow = c(2, 2))
plot(model_y1)
par(mfrow = c(1, 1))

# Interpretaci√≥n:
# - Gr√°fico 1 (Residuals vs Fitted): sin patr√≥n curvil√≠neo ‚Üí ok
# - Gr√°fico 2 (QQ Plot): puntos cerca de la l√≠nea ‚Üí normalidad aceptable
# - Gr√°fico 3 (Scale-Location): dispersi√≥n constante ‚Üí homocedasticidad
# - Gr√°fico 4 (Cook's D): puntos con influencia alta (> 0.5) deben revisarse



# ===========================================================================
# AN√ÅLISIS GR√ÅFICO ENTRE VARIABLES Y ln(PRECIO)   -  violin
#                   (funcion)
# ===========================================================================

graficar_violin_con_box <- function(data, x, y) {
  # Cargar ggplot2 (aseg√∫rate de tenerlo cargado antes o aqu√≠)
  if (!require(ggplot2)) stop("Necesitas instalar: install.packages('ggplot2')")
  
  # Crear gr√°fico
  ggplot(data, aes(x = {{ x }}, y = {{ y }})) +
    geom_violin(trim = FALSE, alpha = 0.5, fill = "skyblue", color = NA) +
    geom_boxplot(width = 0.15, outlier.shape = NA, alpha = 0.8, fill = "white") +
    geom_jitter(aes(color = {{ x }}), width = 0.2, alpha = 0.6, size = 1) +
    theme_minimal() +
    labs(
      title = paste("Distribuci√≥n de", deparse(substitute(y)), "por", deparse(substitute(x))),
      x = deparse(substitute(x)),
      y = deparse(substitute(y))
    ) +
    guides(color = "none") +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
      plot.title = element_text(size = 12)
    )
}

graficar_violin_con_box(df, x = tienda, y = ln_precio)
graficar_violin_con_box(df, x = marca, y = ln_precio)
graficar_violin_con_box(df, x = resolucion, y = ln_precio)
graficar_violin_con_box(df, x = nucleos, y = ln_precio)
graficar_violin_con_box(df_vertical_cable, x = potencia_watts, y = ln_precio)
graficar_violin_con_box(df_vertical_cable, x = filtro_hepa, y = ln_precio)
graficar_violin_con_box(df_robot, x = sistema_operativo, y = ln_precio)
graficar_violin_con_box(df_robot, x = definicion_pantalla, y = ln_precio)

colnames(df)


# ===========================================================================
# AN√ÅLISIS GR√ÅFICO ENTRE VARIABLES Y ln(PRECIO)   -  box plot
#                   (funcion)
# ===========================================================================

graficar_boxplot <- function(data, x, y) {
  if (!require(ggplot2)) stop("Necesitas instalar: install.packages('ggplot2')")
  
  ggplot(data, aes(x = factor({{ x }}), y = {{ y }}, fill = factor({{ x }}))) +
    geom_boxplot(alpha = 0.7, outlier.color = "red", outlier.size = 1.5) +
    theme_minimal() +
    labs(
      title = paste("Distribuci√≥n de", deparse(substitute(y)), "por", deparse(substitute(x))),
      x = deparse(substitute(x)),
      y = deparse(substitute(y))
    ) +
    guides(fill = "none") +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
      plot.title = element_text(size = 12)
    )
}

graficar_boxplot(df, x = capacidad_bateria, y = ln_precio)
graficar_boxplot(df, x = peso, y = ln_precio)
graficar_boxplot(df, x = almacenamiento, y = ln_precio)
graficar_boxplot(df, x = ram, y = ln_precio)
graficar_boxplot(df, x = screen_size, y = ln_precio)
graficar_boxplot(df, x = camara_frontal, y = ln_precio)
graficar_boxplot(df, x = camara_posterior, y = ln_precio)

